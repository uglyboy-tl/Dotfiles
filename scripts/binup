#!/usr/bin/env bash
# è‡ªåŠ¨ç”Ÿæˆ - 2026-01-23T12:13:49+08:00
set -euo pipefail

# è„šæœ¬é…ç½® (æ„å»ºæ—¶æŒ‡å®š: SCRIPT_NAME=BinUp)
SCRIPT_NAME="BinUp"
VERSION="0.1.0"


##### BEGIN: lib/config.sh #####


# Global configuration variables (export for subshells)
# SCRIPT_NAME ä»å‰æ–‡ç»§æ‰¿ï¼Œæœªè®¾ç½®æ—¶é»˜è®¤ä¸º BinUp
: "${SCRIPT_NAME:=BinUp}"
CONFIG_FILE=""
SETTINGS_DOWNLOAD_DIR="downloads"
SETTINGS_PROXY_PREFIX=""
SETTINGS_LOG_LEVEL="info"
SETTINGS_GITHUB_TOKEN=""
CONFIG_LOADED=false

# Find configuration file path (priority order):
# 1. BIN_UPDATER_CONFIG environment variable
# 2. XDG_CONFIG_HOME/{script_name_lowercase}/config.toml
# 3. ~/.config/{script_name_lower}/config.toml
# 4. config.toml (local directory)
# Returns the path on success, nothing on failure
find_config_file() {
    local script_name_lower="${SCRIPT_NAME,,}"

    if [[ -n "${BIN_UPDATER_CONFIG:-}" && -f "$BIN_UPDATER_CONFIG" ]]; then
        echo "$BIN_UPDATER_CONFIG"
        return 0
    elif [[ -n "${XDG_CONFIG_HOME:-}" && -f "${XDG_CONFIG_HOME}/${script_name_lower}/config.toml" ]]; then
        echo "${XDG_CONFIG_HOME}/${script_name_lower}/config.toml"
        return 0
    elif [[ -f "$HOME/.config/${script_name_lower}/config.toml" ]]; then
        echo "$HOME/.config/${script_name_lower}/config.toml"
        return 0
    elif [[ -f "config.toml" ]]; then
        echo "config.toml"
        return 0
    fi

    return 1
}

# Get config file path to edit (creates if doesn't exist)
get_edit_config_path() {
    local script_name_lower="${SCRIPT_NAME,,}"

    # Try to find existing config first
    if find_config_file >/dev/null 2>&1; then
        find_config_file
        return 0
    fi

    # No existing config, determine where to create
    if [[ -n "${BIN_UPDATER_CONFIG:-}" ]]; then
        echo "$BIN_UPDATER_CONFIG"
    else
        echo "${XDG_CONFIG_HOME:-$HOME/.config}/${script_name_lower}/config.toml"
    fi
}

# Create empty config file with default template
create_default_config() {
    local config_path="$1"
    local config_dir
    config_dir=$(dirname "$config_path")

    # Create parent directory if needed
    if [[ ! -d "$config_dir" ]]; then
        mkdir -p "$config_dir"
        log_info "Created config directory: $config_dir"
    fi

    log_info "Creating default config: $config_path"
    cat > "$config_path" << 'EOF'
# Bin Updater Configuration
# Edit this file to configure package sources and settings

[settings]
# download_dir = "downloads"
# proxy_prefix = ""
# log_level = "info"  # debug, info, warn, error, none
# github_token = ""

# [[packages.<name>]]
# repo = "owner/repo"
# file_pattern = "<name>-{os}-{arch}.tar.gz"
# file_extension = "tar.gz"
# version_type = "release"  # release or tag
# binary_name = "<binary>"

# Example configuration:
# [packages.ripgrep]
# repo = "BurntSushi/ripgrep"
# file_pattern = "ripgrep-{os}-{arch}.tar.gz"
# file_extension = "tar.gz"
# version_type = "release"
# binary_name = "rg"
EOF
}

# Load configuration from TOML file
load_config() {
    local config_file

    # Find config file
    config_file=$(find_config_file) || {
        # No existing config, create one automatically
        local new_config_path
        new_config_path=$(get_edit_config_path)
        create_default_config "$new_config_path"
        config_file="$new_config_path"
        log_info "Config file created. Edit it with: $0 edit"
    }

    log_debug "Loading config from: $config_file"
    CONFIG_FILE="$config_file"

    # Parse [settings] section with improved TOML parsing
    if grep -q '^\[settings\]' "$config_file"; then
        local in_settings=false
        while IFS= read -r line; do
            # Remove inline comments and trim trailing whitespace
            line="${line%%#*}"
            line="${line%"${line##*[![:space:]]}"}"

            if [[ -z "$line" ]]; then
                continue  # Skip empty lines
            fi

            if [[ "$line" == "[settings]" ]]; then
                in_settings=true
            elif [[ "$line" == "["* ]] && [[ "$in_settings" == true ]]; then
                break
            elif [[ "$in_settings" == true ]]; then
                # Match key = value with optional quotes and spaces
                if [[ "$line" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
                    local key="${BASH_REMATCH[1]}"
                    local value="${BASH_REMATCH[2]}"

                    # Remove surrounding quotes if present
                    if [[ "$value" =~ ^\"(.*)\"$ ]]; then
                        value="${BASH_REMATCH[1]}"
                    elif [[ "$value" =~ ^\'(.*)\'$ ]]; then
                        value="${BASH_REMATCH[1]}"
                    fi

                    case "$key" in
                        download_dir)
                            SETTINGS_DOWNLOAD_DIR="$value"
                            ;;
                        proxy_prefix)
                            SETTINGS_PROXY_PREFIX="$value"
                            ;;
                        log_level)
                            SETTINGS_LOG_LEVEL="$value"
                            ;;
                        github_token)
                            SETTINGS_GITHUB_TOKEN="$value"
                            # Also set as environment variable for GitHub API
                            if [[ -n "$value" ]]; then
                                export GITHUB_TOKEN="$value"
                            fi
                            ;;
                    esac
                fi
            fi
        done < "$config_file"
    fi

    # Apply environment variable overrides
    if [[ -n "${BIN_UPDATER_DOWNLOAD_DIR:-}" ]]; then
        SETTINGS_DOWNLOAD_DIR="$BIN_UPDATER_DOWNLOAD_DIR"
        log_debug "Using download dir from environment: $SETTINGS_DOWNLOAD_DIR"
    fi

    # Validate and secure download directory path
    if [[ -n "$SETTINGS_DOWNLOAD_DIR" ]]; then
        # Get absolute path and canonicalize (resolve symlinks, remove .., etc.)
        local abs_download_dir
        abs_download_dir="$(realpath --canonicalize-missing "$SETTINGS_DOWNLOAD_DIR")"

        # If it's an absolute path outside current directory, allow it
        # (this is useful for external download directories)
        if [[ "$abs_download_dir" != /* ]]; then
            # Relative path - ensure it's within the current directory tree for security
            local current_dir
            current_dir="$(pwd)"
            if [[ "$abs_download_dir" != "$current_dir"/* ]] && [[ "$abs_download_dir" != "$current_dir" ]]; then
                log_error "Download directory path traversal detected: $SETTINGS_DOWNLOAD_DIR"
                exit 1
            fi
        fi

        SETTINGS_DOWNLOAD_DIR="$abs_download_dir"
    fi

    # è§£æåŒ…é…ç½®
    if [[ -f "_NONE_/lib/packages.sh" ]]; then
        source "_NONE_/lib/packages.sh"
    fi

    if ! declare -f init_logging >/dev/null 2>&1; then
        log_error "Connot load lib/packages.sh";
    else
        parse_packages
    fi

    # Create necessary directories with error handling
    mkdir -p "$SETTINGS_DOWNLOAD_DIR" || {
        log_error "Failed to create download directory: $SETTINGS_DOWNLOAD_DIR"
        exit 1
    }
}

##### END: lib/config.sh #####

##### BEGIN: lib/deps.sh #####


# Dependency check utilities

# Check required dependencies
check_dependencies() {
    local missing_deps=()

    # Check for required commands (jq and tar are strictly required)
    command -v jq >/dev/null 2>&1 || missing_deps+=("jq")
    command -v tar >/dev/null 2>&1 || missing_deps+=("tar")

    # Check for download tools (curl or wget, at least one required)
    local has_download_tool=false
    command -v curl >/dev/null 2>&1 && has_download_tool=true
    command -v wget >/dev/null 2>&1 && has_download_tool=true

    if [[ "$has_download_tool" == "false" ]]; then
        missing_deps+=("curl or wget")
    fi

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        echo "Error: Missing required dependencies: ${missing_deps[*]}"
        echo "Please install them and try again."
        return 1
    fi

    # Check for optional but recommended commands
    local optional_missing=()
    command -v curl >/dev/null 2>&1 || optional_missing+=("curl")
    command -v wget >/dev/null 2>&1 || optional_missing+=("wget")
    command -v unzip >/dev/null 2>&1 || optional_missing+=("unzip")
    command -v gzip >/dev/null 2>&1 || optional_missing+=("gzip")

    if [[ ${#optional_missing[@]} -gt 0 ]]; then
        log_warn "Missing optional dependencies: ${optional_missing[*]}"
        echo "Warning: Missing optional dependencies: ${optional_missing[*]}"
        echo "  Download tools (curl/wget) and archive tools (unzip/gzip) are recommended."
    fi

    log_info "All required dependencies are available"

    return 0
}

# Print dependency status
print_dependency_status() {
    echo "Dependency Status:"
    echo "=================="

    # Required dependencies
    local deps=("jq" "tar")
    for dep in "${deps[@]}"; do
        if command -v "$dep" >/dev/null 2>&1; then
            local version
            version=$($dep --version 2>/dev/null | head -1 || echo "unknown")
            echo "  $dep: âœ“ ($version)"
        else
            echo "  $dep: âœ— (missing, required)"
        fi
    done

    # Download tools (at least one required)
    echo ""
    echo "Download tools (need at least one):"
    local download_tools=("curl" "wget")
    local has_tool=false
    for dep in "${download_tools[@]}"; do
        if command -v "$dep" >/dev/null 2>&1; then
            local version
            version=$($dep --version 2>/dev/null | head -1 || echo "unknown")
            echo "  $dep: âœ“ ($version)"
            has_tool=true
        else
            echo "  $dep: âœ— (missing, recommended)"
        fi
    done
    if [[ "$has_tool" == "false" ]]; then
        echo "  âš ï¸  No download tool found! Install curl or wget."
    fi

    echo ""
    echo "Optional:"
    local optional_deps=("unzip" "gzip")
    for dep in "${optional_deps[@]}"; do
        if command -v "$dep" >/dev/null 2>&1; then
            local version
            version=$($dep --version 2>/dev/null | head -1 || echo "unknown")
            echo "  $dep: âœ“ ($version)"
        else
            echo "  $dep: âœ— (missing, optional)"
        fi
    done
}

##### END: lib/deps.sh #####

##### BEGIN: lib/download.sh #####


# ä¸‹è½½å·¥å…·é€‰æ‹©ï¼ˆä¼˜å…ˆçº§: curl > wgetï¼‰
_DOWNLOAD_TOOL=""
_DOWNLOAD_TOOL_SELECTED=false

# è·å–ä¸‹è½½å·¥å…·åç§°
_get_download_tool() {
    if [[ "$_DOWNLOAD_TOOL_SELECTED" == "false" ]]; then
        if command -v curl >/dev/null 2>&1; then
            _DOWNLOAD_TOOL="curl"
        elif command -v wget >/dev/null 2>&1; then
            _DOWNLOAD_TOOL="wget"
        else
            _DOWNLOAD_TOOL=""
        fi
        _DOWNLOAD_TOOL_SELECTED=true
    fi
    echo "$_DOWNLOAD_TOOL"
}

# ä½¿ç”¨ curl ä¸‹è½½
_download_with_curl() {
    local url="$1"
    local output_file="$2"
    # -L: è·Ÿè¸ªé‡å®šå‘
    # -#: æ˜¾ç¤ºè¿›åº¦æ¡
    # -C -: æ–­ç‚¹ç»­ä¼ 
    curl -4 -L -C - -o "$output_file" "$url"
}

# ä½¿ç”¨ wget ä¸‹è½½
_download_with_wget() {
    local url="$1"
    local output_file="$2"
    # -c: æ–­ç‚¹ç»­ä¼ 
    # --progress=dot: ä½¿ç”¨ç‚¹çŠ¶è¿›åº¦æ¡ï¼ˆæ›´ç®€æ´ï¼‰
    # -O: è¾“å‡ºåˆ°æ–‡ä»¶
    wget -c --progress=dot -O "$output_file" "$url"
}

# ä¸‹è½½æ–‡ä»¶ï¼ˆæ”¯æŒä»£ç†å‰ç¼€ï¼Œè‡ªåŠ¨é€‰æ‹©å·¥å…·ï¼‰
download_file() {
    local url="$1"
    local output_file="$2"

    # å¦‚æœé…ç½®äº†ä»£ç†å‰ç¼€ï¼Œä¿®æ”¹ URL
    local actual_url="$url"
    if [[ -n "$SETTINGS_PROXY_PREFIX" ]]; then
        actual_url="${url#https://github.com/}"
        actual_url="${SETTINGS_PROXY_PREFIX}${actual_url}"
    fi

    # è¾“å‡ºä¸‹è½½ URL
    echo "  [URL] $actual_url"

    # é€‰æ‹©ä¸‹è½½å·¥å…·
    local tool
    tool=$(_get_download_tool)

    if [[ -z "$tool" ]]; then
        echo "  [é”™è¯¯] æœªæ‰¾åˆ° curl æˆ– wgetï¼Œæ— æ³•ä¸‹è½½"
        return 1
    fi

    echo "  [å·¥å…·] ä½¿ç”¨ $tool ä¸‹è½½"

    # æ‰§è¡Œä¸‹è½½
    case "$tool" in
        curl)
            _download_with_curl "$actual_url" "$output_file"
            ;;
        wget)
            _download_with_wget "$actual_url" "$output_file"
            ;;
    esac
}

# æ£€æŸ¥ä¸‹è½½å·¥å…·æ˜¯å¦å¯ç”¨
check_download_tool() {
    local tool
    tool=$(_get_download_tool)
    if [[ -n "$tool" ]]; then
        return 0
    fi
    return 1
}

# å¤‡ä»½æ–‡ä»¶åˆ° downloads/backups ç›®å½•ï¼ˆä½¿ç”¨ç§»åŠ¨è€Œéå¤åˆ¶ï¼‰
backup_file() {
    local package="$1"
    local version="$2"
    local filename="$3"

    local source_file="$SETTINGS_DOWNLOAD_DIR/$filename"
    local backup_dir="$SETTINGS_DOWNLOAD_DIR/backups"
    local timestamp=$(date +%Y%m%d-%H%M%S)
    
    # æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦æœ‰åç¼€
    if [[ "$filename" =~ \. ]]; then
        local backup_file="${backup_dir}/${package}-${version}-${timestamp}.${filename##*.}"
    else
        # æ— åç¼€æ–‡ä»¶
        local backup_file="${backup_dir}/${package}-${version}-${timestamp}"
    fi

    mkdir -p "$backup_dir"
    mv "$source_file" "$backup_file"
    echo "$backup_file"
}

# è§£å‹æ–‡ä»¶
extract_file() {
    local filename="$1"
    local extract_dir="$2"

    local file_path="$SETTINGS_DOWNLOAD_DIR/$filename"
    mkdir -p "$extract_dir"

    # æ£€æŸ¥æ˜¯å¦æ˜¯æ— åç¼€çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼ˆç›´æ¥æä¾›çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼‰
    if [[ ! "$filename" =~ \. ]]; then
        # æ— åç¼€æ–‡ä»¶ï¼Œç›´æ¥å¤åˆ¶åˆ°è§£å‹ç›®å½•
        cp "$file_path" "$extract_dir/"
        chmod +x "$extract_dir/$(basename "$filename")"
        return 0
    fi

    # æ ¹æ®æ–‡ä»¶æ‰©å±•åé€‰æ‹©è§£å‹æ–¹å¼
    if [[ "$filename" == *.zip ]]; then
        unzip -q "$file_path" -d "$extract_dir"
    elif [[ "$filename" == *.tar.gz ]] || [[ "$filename" == *.tgz ]]; then
        tar -xzf "$file_path" -C "$extract_dir"
    elif [[ "$filename" == *.tar.xz ]] || [[ "$filename" == *.txz ]]; then
        tar -xJf "$file_path" -C "$extract_dir"
    elif [[ "$filename" == *.tar.bz2 ]] || [[ "$filename" == *.tbz2 ]]; then
        tar -xjf "$file_path" -C "$extract_dir"
    else
        return 1
    fi
}

# æ¸…ç†æ—§ç‰ˆæœ¬æ–‡ä»¶ï¼ˆä¿ç•™æœ€æ–°Nä¸ªï¼‰
cleanup_old_versions() {
    local package="$1"
    local keep="${2:-3}"

    # ä¿ç•™æœ€æ–°çš„ keep ä¸ªæ–‡ä»¶
    ls -t "$SETTINGS_DOWNLOAD_DIR"/${package}-* 2>/dev/null | tail -n +$((keep + 1)) | xargs -r rm -f
}

##### END: lib/download.sh #####

##### BEGIN: lib/github.sh #####


# ============================================
# GitHub Releases API - ç²¾ç®€ç‰ˆ
# ä»…ç”¨äº update å‘½ä»¤è·å–äº‘ç«¯ä¿¡æ¯
# ============================================

_github_fetch_release() {
    local repo="$1"
    local version_type="${2:-release}"

    local api_url="https://api.github.com/repos/$repo/releases"
    local response

    local curl_args=("-s" "-4")

    if [[ -n "${GITHUB_TOKEN:-}" ]]; then
        curl_args+=("-H" "Authorization: token $GITHUB_TOKEN")
    fi

    response=$(curl "${curl_args[@]}" "$api_url")

    if [[ -z "$response" ]]; then
        log_error "Failed to fetch releases for $repo"
        return 1
    fi

    if echo "$response" | grep -q "rate limit"; then
        log_error "GitHub API rate limit exceeded"
        return 1
    fi

    if [[ "$version_type" == "release" ]]; then
        echo "$response" | jq -r '[.[] | select(.prerelease == false)][0]'
    else
        echo "$response" | jq -r '.[0]'
    fi
}

# åœ¨ assets ä¸­æŸ¥æ‰¾åŒ¹é…çš„ä¸‹è½½ URL
_find_matching_asset_url() {
    local assets="$1"
    local full_pattern="$2"

    echo "$assets" | jq -r ".[] | select(.name | test(\"$full_pattern\"; \"i\")) | .browser_download_url" | head -1
}

# æ¸…ç†ç‰ˆæœ¬å·ï¼šå»æ‰ä»»æ„å‰ç¼€ï¼Œåªä¿ç•™æ•°å­—ç‰ˆæœ¬
_clean_version() {
    local version="$1"
    # åŒ¹é…ç±»ä¼¼ 1.2.3, 1.2 è¿™æ ·çš„ç‰ˆæœ¬å·æ ¼å¼ï¼Œå¹¶å»æ‰å‰ç¼€
    if [[ "$version" =~ ([0-9]+\.[0-9]+(\.[0-9]+)?) ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo "$version"
    fi
}

# è·å–æœ€æ–°ç‰ˆæœ¬å’Œä¸‹è½½ URL
# å‚æ•°: $1=ä»“åº“å, $2=ç‰ˆæœ¬ç±»å‹, $3=file_pattern, $4=file_extension
# è¾“å‡º: VERSION|||URL
get_latest_version_and_url() {
    local repo="$1"
    local version_type="${2:-release}"
    local file_pattern="$3"
    local file_extension="$4"

    local latest
    latest=$(_github_fetch_release "$repo" "$version_type") || return 1

    [[ "$latest" == "null" ]] && return 1

    local version
    version=$(echo "$latest" | jq -r '.tag_name // .name')
    version=$(_clean_version "$version")
    [[ -z "$version" || "$version" == "null" ]] && return 1

    local assets
    assets=$(echo "$latest" | jq -r '.assets')

    # ä½¿ç”¨ platform.sh çš„å‡½æ•°æ„å»ºæ­£åˆ™è¡¨è¾¾å¼ï¼Œä¸€æ¬¡åŒ¹é…æ‰€æœ‰å˜ä½“
    local pattern
    pattern=$(build_pattern_with_placeholders "$file_pattern")
    pattern="${pattern//\*/.*}"
    pattern="${pattern//\?/.}"

    # æ„å»ºå®Œæ•´çš„æ­£åˆ™è¡¨è¾¾å¼ç”¨äºåŒ¹é…
    local full_pattern="$pattern"
    if [[ -n "$file_extension" ]]; then
        full_pattern="${pattern}[.][^.]*${file_extension}$"
    else
        # æ— åç¼€æ–‡ä»¶ï¼ŒåŒ¹é…åˆ°æ–‡ä»¶æœ«å°¾
        full_pattern="${pattern}$"
    fi

    log_debug "Matching regex: $full_pattern"

    local download_url
    download_url=$(_find_matching_asset_url "$assets" "$full_pattern")

    [[ -z "$download_url" || "$download_url" == "null" ]] && return 1

    echo "${version}|||${download_url}"
}

##### END: lib/github.sh #####

##### BEGIN: lib/log.sh #####


# Comprehensive logging module for bin-updater
# Features: timestamped log files, auto-cleanup, silent terminal for log functions


readonly LOG_LEVEL_DEBUG=0
readonly LOG_LEVEL_INFO=1
readonly LOG_LEVEL_WARN=2
readonly LOG_LEVEL_ERROR=3
readonly LOG_LEVEL_NONE=4

SETTINGS_LOG_LEVEL="${SETTINGS_LOG_LEVEL:-info}"

# ä» config.sh è¯»å–è„šæœ¬åç§°
SCRIPT_NAME_LOWER="${SCRIPT_NAME,,}"

# XDG æ•°æ®ç›®å½•ï¼š$XDG_DATA_HOME/{script_name_lower}/logs
# é»˜è®¤å›é€€ï¼š~/.local/share/{script_name_lower}/logs
if [[ -n "${XDG_DATA_HOME:-}" ]]; then
    LOG_DIR="${XDG_DATA_HOME}/${SCRIPT_NAME_LOWER}/logs"
else
    LOG_DIR="${HOME}/.local/share/${SCRIPT_NAME_LOWER}/logs"
fi

LOG_FILE=""
LOG_MAX_FILES=10

LOG_FD=""

_cleanup_old_logs() {
    local count=0
    for log in "$LOG_DIR"/${SCRIPT_NAME_LOWER}-*.log; do
        [[ -f "$log" ]] || continue
        ((count++)) || true
    done

    if [[ $count -gt $LOG_MAX_FILES ]]; then
        local to_delete=$((count - LOG_MAX_FILES))
        for log in "$LOG_DIR"/${SCRIPT_NAME_LOWER}-*.log; do
            [[ -f "$log" ]] || continue
            rm -f "$log"
            ((to_delete--)) || true
            [[ $to_delete -eq 0 ]] && break
        done
    fi
}

init_logging() {
    if [[ ! -d "$LOG_DIR" ]]; then
        mkdir -p "$LOG_DIR" || {
            echo "[ERROR] Failed to create log directory: $LOG_DIR" >&2
            return 1
        }
    fi

    _cleanup_old_logs

    local timestamp
    timestamp=$(date +"%Y%m%d-%H%M%S")
    LOG_FILE="$LOG_DIR/${SCRIPT_NAME_LOWER}-${timestamp}.log"

    exec 3>>"$LOG_FILE" || {
        echo "[ERROR] Failed to open log file: $LOG_FILE" >&2
        return 1
    }
    LOG_FD=3

    _log_file_only "INFO" "Logging initialized. Log file: $LOG_FILE"
}

log_level_to_number() {
    local level="${1:-info}"
    case "${level,,}" in
        debug) echo $LOG_LEVEL_DEBUG ;;
        info)  echo $LOG_LEVEL_INFO ;;
        warn|warning) echo $LOG_LEVEL_WARN ;;
        error) echo $LOG_LEVEL_ERROR ;;
        none)  echo $LOG_LEVEL_NONE ;;
        *)     echo $LOG_LEVEL_INFO ;;
    esac
}

should_log() {
    local message_level="$1"
    local current_level_num=$(log_level_to_number "$SETTINGS_LOG_LEVEL")
    local message_level_num=$(log_level_to_number "$message_level")

    [[ $message_level_num -ge $current_level_num ]]
}

_get_timestamp() {
    date +"%Y-%m-%d %H:%M:%S"
}

_log_file_only() {
    local level="$1"
    local message="$2"
    local timestamp=$(_get_timestamp)

    if [[ -n "${LOG_FD:-}" ]]; then
        echo "[$timestamp] [$level] $message" >&3
    fi
}

# ç”¨æˆ·ç•Œé¢è¾“å‡º - è¾“å‡ºåˆ°ç»ˆç«¯ï¼ŒåŒæ—¶è®°å½•å¸¦æ—¶é—´æˆ³çš„æ—¥å¿—ï¼ˆå»æ‰ç¼©è¿›ï¼‰
log_output() {
    local command="${1:-OUTPUT}"
    local message="$2"

    echo "$message"

    if [[ -n "${LOG_FD:-}" ]]; then
        # å»æ‰ç¼©è¿›ï¼ˆä¸¤ç©ºæ ¼å‰ç¼€ï¼‰åå†™å…¥æ—¥å¿—
        local log_message="${message#  }"
        log_message="${log_message#  }"
        echo "[$(_get_timestamp)] [$command] $log_message" >&3
    fi
}

# æ—¥å¿—ä¿¡æ¯ - åªå†™å…¥æ—¥å¿—æ–‡ä»¶
log_info() {
    _log_file_only "INFO" "$1"
}

# æ—¥å¿—è°ƒè¯• - åªå†™å…¥æ—¥å¿—æ–‡ä»¶
log_debug() {
    if ! should_log "debug"; then
        return 0
    fi
    _log_file_only "DEBUG" "$1"
}

# æ—¥å¿—è­¦å‘Š - åªå†™å…¥æ—¥å¿—æ–‡ä»¶
log_warn() {
    _log_file_only "WARN" "$1"
}

# æ—¥å¿—é”™è¯¯ - åªå†™å…¥æ—¥å¿—æ–‡ä»¶
log_error() {
    _log_file_only "ERROR" "$1"
}

set_log_level() {
    local level="$1"
    if [[ -n "$level" ]]; then
        SETTINGS_LOG_LEVEL="$level"
        log_info "Log level set to: $level"
    fi
}

get_log_level() {
    echo "$SETTINGS_LOG_LEVEL"
}

get_log_tail() {
    local lines="${1:-50}"
    if [[ -f "$LOG_FILE" ]]; then
        tail -n "$lines" "$LOG_FILE"
    fi
}

search_logs() {
    local pattern="$1"
    if [[ -f "$LOG_FILE" ]]; then
        grep -E "$pattern" "$LOG_FILE"
    fi
}

get_log_stats() {
    local total_lines=0
    local error_count=0
    local warn_count=0

    if [[ -f "$LOG_FILE" ]]; then
        total_lines=$(wc -l < "$LOG_FILE")
        error_count=$(grep -c "\[ERROR\]" "$LOG_FILE" || echo 0)
        warn_count=$(grep -c "\[WARN\]" "$LOG_FILE" || echo 0)
    fi

    echo "Log Statistics:"
    echo "  Total lines: $total_lines"
    echo "  Errors: $error_count"
    echo "  Warnings: $warn_count"
    echo "  Log file: $LOG_FILE"
}

close_logging() {
    if [[ -n "${LOG_FD:-}" ]]; then
        _log_file_only "INFO" "Logging closed"
        exec 3>&-
        LOG_FD=""
    fi
}

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    export -f log_info log_warn log_error log_debug
    export -f log_output
    export -f init_logging close_logging set_log_level get_log_level
    export -f get_log_tail search_logs get_log_stats
fi

##### END: lib/log.sh #####

##### BEGIN: lib/packages.sh #####


# åŒ…åˆ—è¡¨æ•°ç»„
PACKAGES=()

# åŒ…é…ç½®å˜é‡ï¼ˆåŠ¨æ€åˆ›å»ºï¼‰
# æ ¼å¼: PKG_<åŒ…å>_<å±æ€§å>
# ä¾‹å¦‚: PKG_bun_REPO, PKG_bun_FILE_PATTERN, PKG_bun_FILE_EXTENSION, etc.

# è§£æåŒ…é…ç½®
parse_packages() {
    local config_file="$CONFIG_FILE"
    local current_package=""


    if declare -f log > /dev/null; then
        log_debug "Parsing packages from: $config_file"
    fi

    # æ¸…ç©ºåŒ…åˆ—è¡¨
    PACKAGES=()

    # è§£æ [packages.<name>] éƒ¨åˆ†
    while IFS= read -r line || [[ -n "$line" ]]; do
        # æ£€æŸ¥æ˜¯å¦æ˜¯åŒ…é…ç½®æ®µçš„å¼€å§‹
        if [[ "$line" =~ ^\[packages\.([a-zA-Z0-9_-]+)\]$ ]]; then
            current_package="${BASH_REMATCH[1]}"
            PACKAGES+=("$current_package")

            # åˆå§‹åŒ–è¯¥åŒ…çš„å˜é‡
            declare -g "PKG_${current_package}_REPO="
            declare -g "PKG_${current_package}_FILE_PATTERN="
            declare -g "PKG_${current_package}_FILE_EXTENSION="
            declare -g "PKG_${current_package}_VERSION_TYPE=release"
            declare -g "PKG_${current_package}_BINARY_NAME=$current_package"

        # åœ¨åŒ…é…ç½®æ®µä¸­ï¼Œè§£æå±æ€§
        elif [[ -n "$current_package" ]]; then
            # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

            # è§£æå„ä¸ªå±æ€§ï¼ˆæ”¯æŒå¸¦å¼•å·å’Œä¸å¸¦å¼•å·çš„å€¼ï¼‰
            if [[ "$line" =~ ^repo[[:space:]]*=[[:space:]]*\"?([^\"#\"]*)\"?[[:space:]]*(#.*)?$ ]]; then
                declare -g "PKG_${current_package}_REPO=${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^file_pattern[[:space:]]*=[[:space:]]*\"([^\"]+)\" ]]; then
                declare -g "PKG_${current_package}_FILE_PATTERN=${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^file_extension[[:space:]]*=[[:space:]]*\"([^\"]+)\" ]]; then
                declare -g "PKG_${current_package}_FILE_EXTENSION=${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^version_type[[:space:]]*=[[:space:]]*\"([^\"]+)\" ]]; then
                declare -g "PKG_${current_package}_VERSION_TYPE=${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^binary_name[[:space:]]*=[[:space:]]*\"([^\"]+)\" ]]; then
                declare -g "PKG_${current_package}_BINARY_NAME=${BASH_REMATCH[1]}"
            fi
        fi
    done < "$config_file"

    # è¾“å‡ºæ—¥å¿—
    if declare -f log_info > /dev/null; then
        log_info "Loaded ${#PACKAGES[@]} packages: ${PACKAGES[*]}"
    fi
}

# è·å–åŒ…å±æ€§å€¼
get_package_property() {
    local package="$1"
    local property="$2"
    local var_name="PKG_${package}_${property}"

    # æ£€æŸ¥åŒ…æ˜¯å¦å­˜åœ¨
    if ! printf '%s\n' "${PACKAGES[@]}" | grep -q "^${package}$"; then
        return 1
    fi

    # è¿”å›å±æ€§å€¼
    echo "${!var_name}"
}

# æ£€æŸ¥åŒ…æ˜¯å¦å­˜åœ¨
package_exists() {
    local package="$1"
    printf '%s\n' "${PACKAGES[@]}" | grep -q "^${package}$"
}

# è·å–æ‰€æœ‰åŒ…å
get_packages() {
    printf '%s\n' "${PACKAGES[@]}"
}

##### END: lib/packages.sh #####

##### BEGIN: lib/platform.sh #####


OS=""
ARCH=""

detect_platform() {
    OS="$(uname -s | tr '[:upper:]' '[:lower:]')"
    case "$OS" in
        darwin)  OS="macos" ;;
        linux)   OS="linux" ;;
        mingw*|msys*|cygwin*) OS="windows" ;;
    esac

    ARCH="$(uname -m)"
    case "$ARCH" in
        x86_64|x64|amd64) ARCH="x86_64" ;;
        aarch64|arm64)    ARCH="aarch64" ;;
        armv7l|armhf)     ARCH="armv7l" ;;
        i686|i386|i586)   ARCH="i686" ;;
    esac

    log_debug "Detected platform: $OS-$ARCH"
}

# Get regex pattern for architecture (includes all known variants)
_get_arch_regex() {
    [[ -z "$ARCH" ]] && detect_platform

    case "$ARCH" in
        x86_64)  echo "(x86_64|x64|amd64)" ;;
        aarch64) echo "(aarch64|arm64)" ;;
        armv7l)  echo "(armv7l|armhf|armv7hl|armv7l-unknown)" ;;
        i686)    echo "(i686|i386|i586)" ;;
        *)       echo "$ARCH" ;;
    esac
}

# Replace {os} and {arch} placeholders
build_pattern_with_placeholders() {
    local pattern="$1"

    [[ -z "$OS" || -z "$ARCH" ]] && detect_platform

    [[ "$pattern" == *"{os}"* ]] && pattern="${pattern//\{os\}/$OS}"
    [[ "$pattern" == *"{arch}"* ]] && pattern="${pattern//\{arch\}/$(_get_arch_regex)}"

    echo "$pattern"
}

##### END: lib/platform.sh #####

##### BEGIN: lib/versions.sh #####


# ç‰ˆæœ¬ä¿¡æ¯ç¼“å­˜ï¼ˆä» versions.toml è¯»å–ï¼‰
VERSIONS_FILE=""
VERSIONS_LOADED=false
declare -gA VERSIONS        # current_version
declare -gA DOWNLOADED     # downloaded (true/false)
declare -gA LATEST_VERSIONS # latest_version (update æ—¶ä¿å­˜)
declare -gA DOWNLOAD_URLS  # download_url (update æ—¶ä¿å­˜)

# åŠ è½½ç‰ˆæœ¬ä¿¡æ¯
load_versions() {
    VERSIONS_FILE="$SETTINGS_DOWNLOAD_DIR/versions.toml"

    # åˆå§‹åŒ–
    VERSIONS=()
    DOWNLOADED=()
    LATEST_VERSIONS=()
    DOWNLOAD_URLS=()

    [[ -f "$VERSIONS_FILE" ]] || { mkdir -p "$SETTINGS_DOWNLOAD_DIR" && touch "$VERSIONS_FILE"; }

    local current_package=""
    while IFS= read -r line || [[ -n "$line" ]]; do
        line="${line%%#*}" line="${line%"${line##*[![:space:]]}"}"
        [[ -z "$line" ]] && continue

        # æ£€æµ‹åŒ…é…ç½®æ®µ [packages.<name>]
        if [[ "$line" =~ ^\[packages\.([a-zA-Z0-9_-]+)\]$ ]]; then
            current_package="${BASH_REMATCH[1]}"
            continue
        fi

        # è§£æé”®å€¼å¯¹
        if [[ "$line" =~ ^[[:space:]]*([a-zA-Z0-9_]+)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            value="${value#\"}" value="${value%\"}"
            value="${value#\'}" value="${value%\'}"

            [[ -z "$current_package" ]] && continue

            case "$key" in
                current_version) VERSIONS["$current_package"]="$value" ;;
                latest_version) LATEST_VERSIONS["$current_package"]="$value" ;;
                download_url) DOWNLOAD_URLS["$current_package"]="$value" ;;
                downloaded) DOWNLOADED["$current_package"]="$value" ;;
            esac
        fi
    done < "$VERSIONS_FILE"

    VERSIONS_LOADED=true
}

# ä¿å­˜å½“å‰ç‰ˆæœ¬ä¿¡æ¯
save_version_info() {
    local package="$1" version="$2" downloaded="${3:-false}"
    [[ -z "$package" ]] && return 1

    [[ "$VERSIONS_LOADED" != true ]] && load_versions
    VERSIONS["$package"]="$version"
    DOWNLOADED["$package"]="$downloaded"
    _save_versions_to_file
}

# ä¿å­˜äº‘ç«¯æœ€æ–°ä¿¡æ¯ï¼ˆupdate å‘½ä»¤ä½¿ç”¨ï¼‰
save_latest_info() {
    local package="$1" version="$2" url="$3"
    [[ -z "$package" ]] && return 1

    [[ "$VERSIONS_LOADED" != true ]] && load_versions
    LATEST_VERSIONS["$package"]="$version"
    DOWNLOAD_URLS["$package"]="$url"
    _save_versions_to_file
}

# å†…éƒ¨å‡½æ•°ï¼šä¿å­˜åˆ°æ–‡ä»¶
_save_versions_to_file() {
    {
        echo "# Version tracking for bin-updater"
        echo "# Auto-generated, do not edit manually"
        echo ""

        # è·å–æ‰€æœ‰åŒ…å
        local all_packages=()
        for pkg in "${!LATEST_VERSIONS[@]}"; do all_packages+=("$pkg"); done
        for pkg in "${!VERSIONS[@]}"; do
            [[ " ${all_packages[*]} " != *" $pkg "* ]] && all_packages+=("$pkg")
        done

        # è¾“å‡ºæ¯ä¸ªåŒ…çš„ä¿¡æ¯
        for pkg in "${all_packages[@]}"; do
            echo "[packages.$pkg]"
            [[ -n "${VERSIONS[$pkg]:-}" ]] && echo "current_version = \"${VERSIONS[$pkg]}\""
            [[ -n "${LATEST_VERSIONS[$pkg]:-}" ]] && echo "latest_version = \"${LATEST_VERSIONS[$pkg]}\""
            [[ -n "${DOWNLOAD_URLS[$pkg]:-}" ]] && echo "download_url = \"${DOWNLOAD_URLS[$pkg]}\""
            echo "downloaded = ${DOWNLOADED[$pkg]:-false}"
            echo ""
        done
    } > "$VERSIONS_FILE"
}

# è¯»å–å‡½æ•°
get_current_version() { local package="$1"; [[ -z "$package" ]] && return 1; [[ "$VERSIONS_LOADED" != true ]] && load_versions; echo "${VERSIONS[$package]:-}"; }
get_latest_version() { local package="$1"; [[ -z "$package" ]] && return 1; [[ "$VERSIONS_LOADED" != true ]] && load_versions; echo "${LATEST_VERSIONS[$package]:-}"; }
get_download_url() { local package="$1"; [[ -z "$package" ]] && return 1; [[ "$VERSIONS_LOADED" != true ]] && load_versions; echo "${DOWNLOAD_URLS[$package]:-}"; }
is_package_downloaded() { local package="$1"; [[ -z "$package" ]] && return 1; [[ "$VERSIONS_LOADED" != true ]] && load_versions; [[ "${DOWNLOADED[$package]:-}" == "true" ]]; }
has_new_version() { local package="$1"; local cur=$(get_current_version "$package"); local latest=$(get_latest_version "$package"); [[ -z "$cur" || "$cur" != "$latest" ]]; }

##### END: lib/versions.sh #####

##### BEGIN: main.sh #####



VERSION="0.1.0"

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

if [[ -f "_NONE_/lib/config.sh" ]]; then
    source "_NONE_/lib/config.sh"
fi

# Source logging library (after config.sh to read SCRIPT_NAME)
if [[ -f "_NONE_/lib/log.sh" ]]; then
    source "_NONE_/lib/log.sh"
fi

# å¦‚æœ myfunc å‡½æ•°å°šæœªå®šä¹‰ï¼Œåˆ™å®šä¹‰å®ƒ
if ! declare -f init_logging >/dev/null 2>&1; then
    echo "Connot load lib/packages.sh";
else
    init_logging
fi


# Source platform detection library
if [[ -f "_NONE_/lib/platform.sh" ]]; then
    source "_NONE_/lib/platform.sh"
fi

# Source GitHub API library
if [[ -f "_NONE_/lib/github.sh" ]]; then
    source "_NONE_/lib/github.sh"
fi

# Source version tracking library
if [[ -f "_NONE_/lib/versions.sh" ]]; then
    source "_NONE_/lib/versions.sh"
fi

# Source download and backup library
if [[ -f "_NONE_/lib/download.sh" ]]; then
    source "_NONE_/lib/download.sh"
fi

# Source dependency check library
if [[ -f "_NONE_/lib/deps.sh" ]]; then
    source "_NONE_/lib/deps.sh"
fi

# Command: list - åˆ—å‡ºå·²ä¸‹è½½çš„åŒ…å’Œæ›´æ–°çŠ¶æ€
cmd_list() {
    log_output "LIST" "å·²ä¸‹è½½çš„åŒ…:"
    log_output "LIST" "============"

    for package in "${PACKAGES[@]}"; do
        current_version=$(get_current_version "$package" 2>/dev/null || echo "")
        latest_version=$(get_latest_version "$package" 2>/dev/null || echo "")
        downloaded=$(is_package_downloaded "$package" 2>/dev/null && echo true || echo false)

        if [[ -n "$current_version" && "$downloaded" == "true" ]]; then
            log_output "LIST" "  $package:"
            log_output "LIST" "    å½“å‰ç‰ˆæœ¬: $current_version"

            file_extension=$(get_package_property "$package" FILE_EXTENSION)
            if [[ -n "$file_extension" ]]; then
                file_pattern="$SETTINGS_DOWNLOAD_DIR/${package}-*.$file_extension"
                matching_files=($file_pattern)
            else
                # æ— åç¼€æ–‡ä»¶ï¼ŒæŸ¥æ‰¾ç²¾ç¡®åŒ¹é…
                matching_files=("$SETTINGS_DOWNLOAD_DIR/${package}-${current_version}")
            fi
            if [[ ${#matching_files[@]} -gt 0 && -f "${matching_files[0]}" ]]; then
                latest_file="${matching_files[0]}"
                download_time=$(stat -c "%y" "$latest_file" | cut -d'.' -f1 | sed 's/ /T/')
                log_output "LIST" "    ä¸‹è½½æ—¶é—´: $download_time"
                log_output "LIST" "    æ–‡ä»¶: $(basename "$latest_file")"
            fi

            if [[ -n "$latest_version" ]]; then
                if [[ "$current_version" != "$latest_version" ]]; then
                    log_output "LIST" "    çŠ¶æ€: ğŸ†• æœ‰æ–°ç‰ˆæœ¬ $latest_version"
                else
                    log_output "LIST" "    çŠ¶æ€: âœ“ å·²æ˜¯æœ€æ–°"
                fi
            else
                log_output "LIST" "    çŠ¶æ€: â„¹ï¸  è¿è¡Œ 'update' è·å–ç‰ˆæœ¬ä¿¡æ¯"
            fi
        elif [[ -n "$latest_version" ]]; then
            log_output "LIST" "  $package:"
            log_output "LIST" "    çŠ¶æ€: ğŸ“¦ æœªä¸‹è½½ (æœ€æ–°: $latest_version)"
            log_output "LIST" "    è¿è¡Œ 'upgrade $package' ä¸‹è½½"
        else
            log_output "LIST" "  $package:"
            log_output "LIST" "    çŠ¶æ€: â„¹ï¸  è¿è¡Œ 'update' è·å–ç‰ˆæœ¬ä¿¡æ¯"
        fi
    done
}

# Command: update - æ£€æŸ¥æ›´æ–°å¹¶ä¿å­˜äº‘ç«¯ä¿¡æ¯
cmd_update() {
    log_output "UPDATE" "æ£€æŸ¥æ›´æ–°:"
    log_output "UPDATE" "=========="

    local has_updates=false

    for package in "${PACKAGES[@]}"; do
        repo=$(get_package_property "$package" REPO)
        version_type=$(get_package_property "$package" VERSION_TYPE)
        file_pattern=$(get_package_property "$package" FILE_PATTERN)
        file_extension=$(get_package_property "$package" FILE_EXTENSION)

        current_version=$(get_current_version "$package" 2>/dev/null)
        downloaded=$(is_package_downloaded "$package" 2>/dev/null && echo true || echo false)

        # è·å–äº‘ç«¯æœ€æ–°ä¿¡æ¯å¹¶ä¿å­˜
        latest_info=$(get_latest_version_and_url "$repo" "$version_type" "$file_pattern" "$file_extension") || {
            log_output "UPDATE" "  $package: è·å–ç‰ˆæœ¬å¤±è´¥"
            continue
        }

        latest_version="${latest_info%%|||*}"
        download_url="${latest_info#*|||}"

        if [[ -z "$latest_version" || -z "$download_url" ]]; then
            log_output "UPDATE" "  $package: è·å–ç‰ˆæœ¬ä¿¡æ¯å¤±è´¥"
            continue
        fi

        # ä¿å­˜äº‘ç«¯ä¿¡æ¯åˆ°æœ¬åœ°
        save_latest_info "$package" "$latest_version" "$download_url"

        # æ˜¾ç¤ºæ›´æ–°çŠ¶æ€
        if [[ "$downloaded" != "true" ]]; then
            log_output "UPDATE" "  $package: æœªä¸‹è½½ (æœ€æ–°: $latest_version)"
            has_updates=true
        elif [[ -z "$current_version" ]]; then
            log_output "UPDATE" "  $package: æœ€æ–°ç‰ˆæœ¬ $latest_version"
        elif [[ "$current_version" != "$latest_version" ]]; then
            log_output "UPDATE" "  $package: æœ‰æ–°ç‰ˆæœ¬ $current_version -> $latest_version"
            has_updates=true
        else
            log_output "UPDATE" "  $package: å·²æ˜¯æœ€æ–°ç‰ˆæœ¬ $current_version"
        fi
    done

    if [[ "$has_updates" == "true" ]]; then
        log_output "UPDATE" ""
        log_output "UPDATE" "è¿è¡Œ './bin-updater.sh upgrade' ä¸‹è½½æ›´æ–°"
    fi
}

# Command: upgrade - ä¸‹è½½æ›´æ–°ï¼ˆä½¿ç”¨æœ¬åœ°ä¿å­˜çš„ä¿¡æ¯ï¼‰
cmd_upgrade() {
    local target_packages=("$@")

    if [[ ${#target_packages[@]} -eq 0 ]]; then
        target_packages=("${PACKAGES[@]}")
    fi

    local packages_to_upgrade=()
    local packages_skipped=0

    for package in "${target_packages[@]}"; do
        if ! printf '%s\n' "${PACKAGES[@]}" | grep -q "^${package}$"; then
            log_error "Unknown package: $package"
            log_error "Available packages: ${PACKAGES[*]}"
            exit 1
        fi
        packages_to_upgrade+=("$package")
    done

    log_output "UPGRADE" "ä¸‹è½½æ›´æ–°:"
    log_output "UPGRADE" "========="

    for package in "${packages_to_upgrade[@]}"; do
        file_extension=$(get_package_property "$package" FILE_EXTENSION)

        local current_version=$(get_current_version "$package" 2>/dev/null)
        local latest_version=$(get_latest_version "$package" 2>/dev/null)
        local download_url=$(get_download_url "$package" 2>/dev/null)
        local downloaded=$(is_package_downloaded "$package" 2>/dev/null && echo true || echo false)

        if [[ -z "$latest_version" ]]; then
            log_output "UPGRADE" "  $package: æ²¡æœ‰äº‘ç«¯ä¿¡æ¯ï¼Œè¯·å…ˆè¿è¡Œ 'update'"
            continue
        fi

        if [[ -z "$download_url" ]]; then
            log_output "UPGRADE" "  $package: æ²¡æœ‰ä¸‹è½½é“¾æ¥ï¼Œè¯·å…ˆè¿è¡Œ 'update'"
            continue
        fi

        local needs_download=false
        local msg=""
        if [[ "$downloaded" != "true" ]]; then
            needs_download=true
            msg="æœªä¸‹è½½ï¼Œå°†ä¸‹è½½ $latest_version"
        elif [[ -z "$current_version" ]]; then
            needs_download=true
            msg="æ— ç‰ˆæœ¬è®°å½•ï¼Œå°†ä¸‹è½½ $latest_version"
        elif [[ "$current_version" != "$latest_version" ]]; then
            needs_download=true
            msg="æœ‰æ–°ç‰ˆæœ¬ $current_version -> $latest_version"
        else
            log_output "UPGRADE" "  $package: å·²æ˜¯æœ€æ–°ç‰ˆæœ¬ $current_version"
            ((packages_skipped++)) || true
            continue
        fi

        log_output "UPGRADE" "  $package: $msg"

        if [[ "$needs_download" == "true" ]]; then
            if [[ "$downloaded" == "true" && -n "$current_version" ]]; then
                if [[ -n "$file_extension" ]]; then
                    old_file="${package}-${current_version}.${file_extension}"
                else
                    old_file="${package}-${current_version}"
                fi
                if [[ -f "$SETTINGS_DOWNLOAD_DIR/$old_file" ]]; then
                    backup_file "$package" "$current_version" "$old_file" > /dev/null
                fi
            fi

            if [[ -n "$file_extension" ]]; then
                filename="${package}-${latest_version}.${file_extension}"
            else
                filename="${package}-${latest_version}"
            fi
            output_file="$SETTINGS_DOWNLOAD_DIR/$filename"

            log_output "UPGRADE" "  [ä¸‹è½½] $filename"
            if download_file "$download_url" "$output_file"; then
                log_output "UPGRADE" "  [å®Œæˆ] ä¸‹è½½æˆåŠŸ"
                save_version_info "$package" "$latest_version" "true"
            else
                log_output "UPGRADE" "  $package: ä¸‹è½½å¤±è´¥"
                rm -f "$output_file"
            fi
        fi
    done

    log_output "UPGRADE" "========="
    local total=${#packages_to_upgrade[@]}
    local updated=$((total - packages_skipped))
    if [[ $total -gt 0 ]]; then
        log_output "UPGRADE" "å…± $total ä¸ªåŒ…ï¼Œ$updated ä¸ªå·²æ›´æ–°ï¼Œ$packages_skipped ä¸ªè·³è¿‡"
    fi
}

# å®‰è£…å•ä¸ªåŒ…çš„å†…éƒ¨å‡½æ•°
_do_install_package() {
    local package="$1"
    local show_header="${2:-true}"

    current_version=$(get_current_version "$package" 2>/dev/null)
    if [[ -z "$current_version" ]]; then
        log_output "INSTALL" "  $package: æœªä¸‹è½½ï¼Œè¯·å…ˆè¿è¡Œ upgrade"
        return 1
    fi

    file_extension=$(get_package_property "$package" FILE_EXTENSION)
    binary_name=$(get_package_property "$package" BINARY_NAME)

    if [[ "$show_header" == "true" ]]; then
        log_output "INSTALL" "  å®‰è£… $package (ç‰ˆæœ¬: $current_version)..."
    fi

    # æ„å»ºæ–‡ä»¶åï¼ˆæ— åç¼€æ—¶ç›´æ¥ç”¨åŒ…å-ç‰ˆæœ¬ï¼‰
    if [[ -n "$file_extension" ]]; then
        filename="${package}-${current_version}.${file_extension}"
    else
        filename="${package}-${current_version}"
    fi
    archive_file="$SETTINGS_DOWNLOAD_DIR/$filename"

    if [[ ! -f "$archive_file" ]]; then
        log_output "INSTALL" "  $package: æ–‡ä»¶ä¸å­˜åœ¨: $archive_file"
        return 1
    fi

    # ç¡®å®šå®‰è£…ç›®å½•
    system_bin="/usr/local/bin"
    user_bin="$HOME/.local/bin"

    if [[ -w "$system_bin" ]]; then
        install_dir="$system_bin"
        log_output "INSTALL" "  [æ£€æµ‹] æœ‰ç³»ç»Ÿç›®å½•å†™å…¥æƒé™ï¼Œä½¿ç”¨ç³»ç»Ÿç›®å½•"
    else
        install_dir="$user_bin"
        log_output "INSTALL" "  [æ£€æµ‹] æ— ç³»ç»Ÿç›®å½•å†™å…¥æƒé™ï¼Œä½¿ç”¨ç”¨æˆ·ç›®å½•"
    fi
    mkdir -p "$install_dir"

    # æ— åç¼€åäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œç›´æ¥å®‰è£…
    if [[ -z "$file_extension" ]]; then
        local target_file="$install_dir/$binary_name"
        log_output "INSTALL" "  [å®‰è£…] $binary_name"
        cp "$archive_file" "$target_file"
        chmod +x "$target_file"
        log_output "INSTALL" "  [å®Œæˆ] å®‰è£…æˆåŠŸ"
        log_output "INSTALL" "  [è·¯å¾„] $install_dir å·²æ·»åŠ åˆ° PATH"
        return 0
    fi

    extract_dir="$SETTINGS_DOWNLOAD_DIR/${package}-${current_version}"
    rm -rf "$extract_dir"
    log_output "INSTALL" "  [è§£å‹] $filename"
    if ! extract_file "$filename" "$extract_dir"; then
        log_output "INSTALL" "  $package: è§£å‹å¤±è´¥"
        rm -rf "$extract_dir"
        return 1
    fi

    local binary_files=()
    while IFS= read -r -d '' binary_file; do
        binary_files+=("$binary_file")
    done < <(find "$extract_dir" -type f -executable -print0 2>/dev/null)

    if [[ ${#binary_files[@]} -eq 0 ]]; then
        while IFS= read -r -d '' binary_file; do
            binary_files+=("$binary_file")
        done < <(find "$extract_dir" -type f -perm /111 -print0 2>/dev/null)
    fi

    if [[ ${#binary_files[@]} -gt 0 ]]; then
        local installed_count=0
        for binary_file in "${binary_files[@]}"; do
            local target_file="$install_dir/$(basename "$binary_file")"
            log_output "INSTALL" "  [å®‰è£…] åˆ° $target_file"
            cp "$binary_file" "$target_file"
            chmod +x "$target_file"
            ((installed_count++)) || true
        done
        rm -rf "$extract_dir"
        log_output "INSTALL" "  [å®Œæˆ] å®‰è£…æˆåŠŸ ($installed_count ä¸ªæ–‡ä»¶)"
        log_output "INSTALL" "  [è·¯å¾„] $install_dir å·²æ·»åŠ åˆ° PATH"
        return 0
    else
        log_output "INSTALL" "  $package: æœªæ‰¾åˆ°å¯æ‰§è¡Œæ–‡ä»¶"
        rm -rf "$extract_dir"
        return 1
    fi
}

# Command: install - å®‰è£…å·²ä¸‹è½½çš„åŒ…
cmd_install() {
    local target_packages=("$@")

    if [[ ${#target_packages[@]} -eq 0 ]]; then
        log_error "Usage: $0 install <package> [package2] ..."
        log_error "Available packages: ${PACKAGES[*]}"
        log_output "INSTALL" ""
        log_output "INSTALL" "ç¤ºä¾‹:"
        log_output "INSTALL" "  $0 install ripgrep          # å®‰è£…å•ä¸ªåŒ…"
        log_output "INSTALL" "  $0 install ripgrep uv       # å®‰è£…å¤šä¸ªåŒ…"
        exit 1
    fi

    for package in "${target_packages[@]}"; do
        if ! printf '%s\n' "${PACKAGES[@]}" | grep -q "^${package}$"; then
            log_error "Unknown package: $package"
            log_error "Available packages: ${PACKAGES[*]}"
            exit 1
        fi
    done

    log_output "INSTALL" "å®‰è£…åŒ…:"
    log_output "INSTALL" "========="

    local success_count=0
    local fail_count=0

    for package in "${target_packages[@]}"; do
        if _do_install_package "$package" "true"; then
            ((success_count++)) || true
        else
            ((fail_count++)) || true
        fi
        log_output "INSTALL" ""
    done

    log_output "INSTALL" "========="
    log_output "INSTALL" "å…± ${#target_packages[@]} ä¸ªåŒ…ï¼Œ$success_count ä¸ªæˆåŠŸï¼Œ$fail_count ä¸ªå¤±è´¥"
}

# Command: edit - ä½¿ç”¨ç³»ç»Ÿç¼–è¾‘å™¨ç¼–è¾‘é…ç½®æ–‡ä»¶
cmd_edit() {
    if ! declare -f get_edit_config_path >/dev/null 2>&1; then
        log_error "æ— æ³•åŠ è½½é…ç½®åº“"
        exit 1
    fi

    if ! declare -f create_default_config >/dev/null 2>&1; then
        log_error "æ— æ³•åŠ è½½é…ç½®åº“"
        exit 1
    fi

    local config_path
    config_path=$(get_edit_config_path)

    # Determine the editor to use (default: vim)
    local editor="${EDITOR:-${VISUAL:-vim}}"

    # Check if editor exists
    if ! command -v "$editor" >/dev/null 2>&1; then
        log_error "æœªæ‰¾åˆ°ç¼–è¾‘å™¨: $editorï¼Œè¯·è®¾ç½® EDITOR ç¯å¢ƒå˜é‡"
        exit 1
    fi

    # Create default config if it doesn't exist
    if [[ ! -f "$config_path" ]]; then
        create_default_config "$config_path"
    fi

    log_output "EDIT" "æ­£åœ¨æ‰“å¼€é…ç½®: $config_path"
    log_output "EDIT" "ç¼–è¾‘å™¨: $editor"

    # Open the editor
    if ! "$editor" "$config_path"; then
        log_error "ç¼–è¾‘å™¨æ‰“å¼€å¤±è´¥: $editor"
        exit 1
    fi

    log_output "EDIT" "é…ç½®æ–‡ä»¶å·²ä¿å­˜: $config_path"

    # Optionally reload the config
    log_info "é…ç½®å·²æ›´æ–°ï¼Œå¯èƒ½éœ€è¦é‡å¯å·¥å…·æˆ–æ‰§è¡Œ source é‡æ–°åŠ è½½"
}

# Main entry point
main() {
    if [[ $# -eq 0 ]]; then
        log_error "Usage: $0 <command>"
        log_error "Commands: list, update, upgrade, install, edit"
        exit 1
    fi

    # Check dependencies first
    if declare -f check_dependencies > /dev/null; then
        check_dependencies || exit 1
    fi

    # Load configuration
    if declare -f load_config > /dev/null; then
        load_config
    fi

    # Detect platform
    if declare -f detect_platform > /dev/null; then
        detect_platform
    fi

    local command="$1"
    shift

    case "$command" in
        list)
            cmd_list
            ;;
        update)
            cmd_update
            ;;
        upgrade)
            cmd_upgrade "$@"
            ;;
        install)
            cmd_install "$@"
            ;;
        edit)
            cmd_edit
            ;;
        *)
            log_error "Unknown command: $command"
            exit 1
            ;;
    esac

    # Close logging before exit
    if declare -f close_logging > /dev/null; then
        close_logging
    fi
}

# Only run main if script is executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi

##### END: main.sh #####
